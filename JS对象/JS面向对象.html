<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
</html>
<script>
  /**
   * 构造函数和对象
   *  一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。
   *  ** 一个构造函数中的方法 在实例化的时候会被重新赋予内存空间  考虑到函数占用内存空间大 建议使用原型定义函数
  */
  function Person(name) {
    this.name = name; // 定义属性
    // this.greeting = function() { // 定义方法 
    //   console.log('hi! ', this.name);
    // }
  }

  Person.prototype.greeting = function() {
    console.log('hi! ', this.name);
  }

  var person1 = new Person('jack');
  var person2 = new Person('zhangsan');

  console.log(person1.name);
  person1.greeting();
  console.log(person2.name)
  person2.greeting();

  console.log(person2);

  /**
   * 创建对象的其他方式
   *  Object()构造函数
   *    var person1 = new Object();
   *  
   *  使用create()方法
   *    var person2 = Object.create(person1);
   *   大多数情况下，__proto__可以理解为“构造器的原型”，即__proto__===constructor.prototype,但是通过 Object.create()创建的对象有可能不是， 
   *   Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
   * 
  */
  var person3 = new Object({
    name: 'sam',
    greeting() {
      console.log('hello ', this.name);
    }
  })
  console.log(person3);
  console.log(person3.__proto__ === person3.constructor.prototype); // true

  var person4 = Object.create(person3);
  console.log(person4);
  console.log(person4.name);
  person4.greeting()
  console.log(person3 === person4.__proto__); // true
  console.log(person4.constructor.prototype === person4.__proto__); // false
</script>